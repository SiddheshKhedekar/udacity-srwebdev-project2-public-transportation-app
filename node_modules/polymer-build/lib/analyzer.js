/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require('path');
const polymer_analyzer_1 = require('polymer-analyzer');
const warning_1 = require('polymer-analyzer/lib/warning/warning');
const stream_1 = require('stream');
const url_1 = require('url');
const logging = require('plylog');
const streams_1 = require('./streams');
const path_transformers_1 = require('./path-transformers');
const minimatchAll = require('minimatch-all');
const logger = logging.getLogger('cli.build.analyzer');
/**
 * Detects if a url is external by checking it's protocol. Also checks if it
 * starts with '//', which can be an alias to the page's current protocol
 * in the browser.
 */
function isDependencyExternal(url) {
    // TODO(fks) 08-01-2016: Add additional check for files on current hostname
    // but external to this application root. Ignore them.
    return url_1.parse(url).protocol !== null || url.startsWith('//');
}
/**
 * Get a longer, single-line error message for logging and exeption-handling
 * analysis Warning objects.
 *
 * Note: We cannot use WarningPrinter.printWarning() from the polymer-analyzer
 * codebase because after minification & optimization its reported source
 * ranges don't match the original source code. Instead we use this custom
 * message generator that only includes the file name in the error message.
 */
function getFullWarningMessage(warning) {
    return `In ${warning.sourceRange.file}: [${warning.code}] - ${warning.message}`;
}
class StreamAnalyzer extends stream_1.Transform {
    constructor(config) {
        super({ objectMode: true });
        this._dependenciesStream = new stream_1.PassThrough({ objectMode: true });
        this._dependenciesProcessingStream = new streams_1.VinylReaderTransform();
        this.files = new Map();
        this.warnings = new Set();
        this.foundDependencies = new Set();
        this._dependencyAnalysis = {
            depsToFragments: new Map(),
            fragmentToDeps: new Map(),
            fragmentToFullDeps: new Map()
        };
        this.config = config;
        this.loader = new StreamLoader(this);
        this.analyzer = new polymer_analyzer_1.Analyzer({
            urlLoader: this.loader,
        });
        // Connect the dependencies stream that the analyzer pushes into to the
        // processing stream which loads each file and attaches the file contents.
        this._dependenciesStream.pipe(this._dependenciesProcessingStream);
        this.allFragmentsToAnalyze = new Set(this.config.allFragments);
        this.analyzeDependencies = new Promise((resolve, _reject) => {
            this._resolveDependencyAnalysis = resolve;
        });
    }
    /**
     * The source dependency stream that Analyzer pushes discovered dependencies
     * into is connected to the post-processing stream. We want consumers to only
     * use the post-processed data so that all file objects have contents
     * loaded by default. This also makes Analyzer easier for us to test.
     */
    get dependencies() {
        return this._dependenciesProcessingStream;
    }
    _transform(file, _encoding, callback) {
        const filePath = file.path;
        this.addFile(file);
        // If our resolver is waiting for this file, resolve its deferred loader
        if (this.loader.hasDeferredFile(filePath)) {
            this.loader.resolveDeferredFile(filePath, file);
        }
        // Propagate the file so that the stream can continue
        callback(null, file);
        // If the file is a fragment, begin analysis on its dependencies
        if (this.config.isFragment(file.path)) {
            (() => __awaiter(this, void 0, void 0, function* () {
                try {
                    const deps = yield this._getDependencies(path_transformers_1.urlFromPath(this.config.root, filePath));
                    this._addDependencies(filePath, deps);
                    this.allFragmentsToAnalyze.delete(filePath);
                    // If there are no more fragments to analyze, close the dependency
                    // stream
                    if (this.allFragmentsToAnalyze.size === 0) {
                        this._dependenciesStream.end();
                    }
                }
                catch (error) {
                    // Because we've already called the _transform callback, we need to
                    // propagate this error via an error on the analyzer stream itself.
                    this.emit('error', error);
                }
            }))();
        }
    }
    _flush(done) {
        this.printWarnings();
        const allWarningCount = this.countWarningsByType();
        const errorWarningCount = allWarningCount.get(warning_1.Severity.ERROR);
        if (errorWarningCount > 0) {
            done(new Error(`${errorWarningCount} error(s) occurred during build.`));
            return;
        }
        // If stream finished with files that still needed to be loaded, error out
        if (this.loader.hasDeferredFiles()) {
            for (const fileUrl of this.loader.deferredFiles.keys()) {
                logger.error(`${fileUrl} never loaded`);
            }
            done(new Error(`${this.loader.deferredFiles.size} deferred files were never loaded`));
            return;
        }
        // Resolve our dependency analysis promise now that we have seen all files
        this._resolveDependencyAnalysis(this._dependencyAnalysis);
        done();
    }
    getFile(filepath) {
        const url = path_transformers_1.urlFromPath(this.config.root, filepath);
        return this.getFileByUrl(url);
    }
    getFileByUrl(url) {
        if (url.startsWith('/')) {
            url = url.substring(1);
        }
        return this.files.get(url);
    }
    /**
     * A side-channel to add files to the loader that did not come throgh the
     * stream transformation. This is for generated files, like
     * shared-bundle.html. This should probably be refactored so that the files
     * can be injected into the stream.
     */
    addFile(file) {
        logger.debug(`addFile: ${file.path}`);
        // Badly-behaved upstream transformers (looking at you gulp-html-minifier)
        // may use posix path separators on Windows.
        const filepath = path.normalize(file.path);
        // Store only root-relative paths, in URL/posix format
        this.files.set(path_transformers_1.urlFromPath(this.config.root, filepath), file);
    }
    printWarnings() {
        for (const warning of this.warnings) {
            const message = getFullWarningMessage(warning);
            if (warning.severity === warning_1.Severity.ERROR) {
                logger.error(message);
            }
            else if (warning.severity === warning_1.Severity.WARNING) {
                logger.warn(message);
            }
            else {
                logger.debug(message);
            }
        }
    }
    countWarningsByType() {
        const errorCountMap = new Map();
        errorCountMap.set(warning_1.Severity.INFO, 0);
        errorCountMap.set(warning_1.Severity.WARNING, 0);
        errorCountMap.set(warning_1.Severity.ERROR, 0);
        for (const warning of this.warnings) {
            errorCountMap.set(warning.severity, errorCountMap.get(warning.severity) + 1);
        }
        return errorCountMap;
    }
    /**
     * Attempts to retreive document-order transitive dependencies for `url`.
     */
    _getDependencies(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = yield this.analyzer.analyze(url);
            doc.getWarnings(true).forEach(w => this.warnings.add(w));
            const scripts = new Set();
            const styles = new Set();
            const imports = new Set();
            for (const importDep of doc.getByKind('import')) {
                const importUrl = importDep.url;
                if (isDependencyExternal(importUrl)) {
                    logger.debug(`ignoring external dependency: ${importUrl}`);
                }
                else if (importDep.type === 'html-script') {
                    scripts.add(importUrl);
                }
                else if (importDep.type === 'html-style') {
                    styles.add(importUrl);
                }
                else if (importDep.type === 'html-import') {
                    imports.add(importUrl);
                }
                else {
                    logger.debug(`unexpected import type encountered: ${importDep.type}`);
                }
            }
            const deps = {
                scripts: Array.from(scripts),
                styles: Array.from(styles),
                imports: Array.from(imports),
            };
            logger.debug(`dependencies analyzed for: ${url}`, deps);
            return deps;
        });
    }
    _addDependencies(filePath, deps) {
        // Make sure function is being called properly
        if (!this.allFragmentsToAnalyze.has(filePath)) {
            throw new Error(`Dependency analysis incorrectly called for ${filePath}`);
        }
        // Add dependencies to _dependencyAnalysis object, and push them through
        // the dependency stream.
        this._dependencyAnalysis.fragmentToFullDeps.set(filePath, deps);
        this._dependencyAnalysis.fragmentToDeps.set(filePath, deps.imports);
        deps.scripts.forEach((url) => this.pushDependency(url));
        deps.styles.forEach((url) => this.pushDependency(url));
        deps.imports.forEach((url) => {
            this.pushDependency(url);
            const entrypointList = this._dependencyAnalysis.depsToFragments.get(url);
            if (entrypointList) {
                entrypointList.push(filePath);
            }
            else {
                this._dependencyAnalysis.depsToFragments.set(url, [filePath]);
            }
        });
    }
    /**
     * Process the given dependency before pushing it through the stream.
     * Each dependency is only pushed through once to avoid duplicates.
     */
    pushDependency(dependencyUrl) {
        if (this.getFileByUrl(dependencyUrl)) {
            logger.debug('dependency has already been pushed, ignoring...', { dep: dependencyUrl });
            return;
        }
        const dependencyFilePath = path_transformers_1.pathFromUrl(this.config.root, dependencyUrl);
        if (minimatchAll(dependencyFilePath, this.config.sources)) {
            logger.debug('dependency is a source file, ignoring...', { dep: dependencyUrl });
            return;
        }
        logger.debug('new dependency found, pushing into dependency stream...', dependencyFilePath);
        this._dependenciesStream.push(dependencyFilePath);
    }
}
exports.StreamAnalyzer = StreamAnalyzer;
;
class StreamLoader {
    constructor(analyzer) {
        // Store files that have not yet entered the Analyzer stream here.
        // Later, when the file is seen, the DeferredFileCallback can be
        // called with the file contents to resolve its loading.
        this.deferredFiles = new Map();
        this.analyzer = analyzer;
        this.config = this.analyzer.config;
    }
    hasDeferredFile(filePath) {
        return this.deferredFiles.has(filePath);
    }
    hasDeferredFiles() {
        return this.deferredFiles.size > 0;
    }
    resolveDeferredFile(filePath, file) {
        const deferred = this.deferredFiles.get(filePath);
        deferred(file.contents.toString());
        this.deferredFiles.delete(filePath);
    }
    canLoad(_url) {
        // We want to return true for all files. Even external files, so that we
        // can resolve them as empty strings for now.
        return true;
    }
    load(url) {
        logger.debug(`loading: ${url}`);
        const urlObject = url_1.parse(url);
        // Resolve external files as empty strings. We filter these out later
        // in the analysis process to make sure they aren't included in the build.
        if (isDependencyExternal(url)) {
            return Promise.resolve('');
        }
        const urlPath = decodeURIComponent(urlObject.pathname);
        const filePath = path_transformers_1.pathFromUrl(this.config.root, urlPath);
        const file = this.analyzer.getFile(filePath);
        if (file) {
            return Promise.resolve(file.contents.toString());
        }
        let callback;
        const waitForFile = new Promise((resolve, _reject) => {
            callback = resolve;
        });
        this.deferredFiles.set(filePath, callback);
        this.analyzer.pushDependency(urlPath);
        return waitForFile;
    }
    /**
     * Wraps the load() method to work in a way that is compliant with vulcanize
     * & the old UrlResolver interface. To be removed once migration from
     * hydrolosis to polymer-analyzer is complete.
     */
    accept(url, deferred) {
        if (this.canLoad(url)) {
            this.load(url).then(deferred.resolve);
            return true;
        }
        return false;
    }
}
exports.StreamLoader = StreamLoader;
