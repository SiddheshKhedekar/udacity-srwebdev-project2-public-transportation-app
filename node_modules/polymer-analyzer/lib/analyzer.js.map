{"version":3,"sources":["analyzer.ts"],"names":[],"mappings":"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","file":"analyzer.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/// <reference path=\"../custom_typings/main.d.ts\" />\n\nimport * as path from 'path';\n\nimport {CssParser} from './css/css-parser';\nimport {HtmlCustomElementReferenceScanner} from './html/html-element-reference-scanner';\nimport {HtmlImportScanner} from './html/html-import-scanner';\nimport {HtmlParser} from './html/html-parser';\nimport {HtmlScriptScanner} from './html/html-script-scanner';\nimport {HtmlStyleScanner} from './html/html-style-scanner';\nimport {JavaScriptParser} from './javascript/javascript-parser';\nimport {JsonParser} from './json/json-parser';\nimport {Document, InlineDocInfo, LocationOffset, ScannedDocument, ScannedElement, ScannedFeature, ScannedImport, ScannedInlineDocument} from './model/model';\nimport {ParsedDocument} from './parser/document';\nimport {Parser} from './parser/parser';\nimport {Measurement, TelemetryTracker} from './perf/telemetry';\nimport {BehaviorScanner} from './polymer/behavior-scanner';\nimport {CssImportScanner} from './polymer/css-import-scanner';\nimport {DomModuleScanner} from './polymer/dom-module-scanner';\nimport {PolymerElementScanner} from './polymer/polymer-element-scanner';\nimport {scan} from './scanning/scan';\nimport {Scanner} from './scanning/scanner';\nimport {UrlLoader} from './url-loader/url-loader';\nimport {UrlResolver} from './url-loader/url-resolver';\nimport {ElementScanner as VanillaElementScanner} from './vanilla-custom-elements/element-scanner';\nimport {Severity, Warning, WarningCarryingException} from './warning/warning';\n\nexport interface Options {\n  urlLoader: UrlLoader;\n  urlResolver?: UrlResolver;\n  parsers?: Map<string, Parser<any>>;\n  scanners?: ScannerTable;\n  /*\n   * Map from url of an HTML Document to another HTML document it lazily depends\n   * on.\n   */\n  lazyEdges?: LazyEdgeMap;\n}\n\nexport class NoKnownParserError extends Error {};\n\nexport type ScannerTable = Map<string, Scanner<any, any, any>[]>;\nexport type LazyEdgeMap = Map<string, string[]>;\n\n/**\n * A static analyzer for web projects.\n *\n * An Analyzer can load and parse documents of various types, and extract\n * arbitratrary information from the documents, and transitively load\n * dependencies. An Analyzer instance is configured with parsers, and scanners\n * which do the actual work of understanding different file types.\n */\nexport class Analyzer {\n  private _parsers = new Map<string, Parser<ParsedDocument<any, any>>>([\n    ['html', new HtmlParser()],\n    ['js', new JavaScriptParser({sourceType: 'script'})],\n    ['css', new CssParser()],\n    ['json', new JsonParser()],\n  ]);\n\n  /** A map from import url to urls that document lazily depends on. */\n  private _lazyEdges: LazyEdgeMap|undefined;\n\n  private _scanners: ScannerTable;\n\n  private _loader: UrlLoader;\n  private _resolver: UrlResolver|undefined;\n\n  private _parsedDocumentPromises =\n      new Map<string, Promise<ParsedDocument<any, any>>>();\n  private _scannedDocumentPromises =\n      new Map<string, Promise<ScannedDocument>>();\n  private _analyzedDocumentPromises = new Map<string, Promise<Document>>();\n\n  private _scannedDocuments = new Map<string, ScannedDocument>();\n  private _analyzedDocuments = new Map<string, Document>();\n\n  private _telemetryTracker = new TelemetryTracker();\n\n  private static _getDefaultScanners(lazyEdges: LazyEdgeMap|undefined) {\n    return new Map<string, Scanner<any, any, any>[]>([\n      [\n        'html',\n        [\n          new HtmlImportScanner(lazyEdges),\n          new HtmlScriptScanner(),\n          new HtmlStyleScanner(),\n          new DomModuleScanner(),\n          new CssImportScanner(),\n          new HtmlCustomElementReferenceScanner()\n        ]\n      ],\n      [\n        'js',\n        [\n          new PolymerElementScanner(),\n          new BehaviorScanner(),\n          new VanillaElementScanner()\n        ]\n      ],\n    ]);\n  }\n\n  constructor(options: Options) {\n    this._loader = options.urlLoader;\n    this._resolver = options.urlResolver;\n    this._parsers = options.parsers || this._parsers;\n    this._lazyEdges = options.lazyEdges;\n    this._scanners =\n        options.scanners || Analyzer._getDefaultScanners(this._lazyEdges);\n  }\n\n  /**\n   * Loads, parses and analyzes the root document of a dependency graph and its\n   * transitive dependencies.\n   *\n   * Note: The analyzer only supports analyzing a single root for now. This\n   * is because each analyzed document in the dependency graph has a single\n   * root. This mean that we can't properly analyze app-shell-style, lazy\n   * loading apps.\n   *\n   * @param contents Optional contents of the file when it is known without\n   * reading it from disk. Clears the caches so that the news contents is used\n   * and reanalyzed. Useful for editors that want to re-analyze changed files.\n   */\n  async analyze(url: string, contents?: string): Promise<Document> {\n    const resolvedUrl = this._resolveUrl(url);\n\n    // if we're given new contents, clear the cache\n    // TODO(justinfagnani): It might be better to preserve a single code path\n    // for loading file contents via UrlLoaders, and just offer a method to\n    // re-analyze a particular file. Editors can use a UrlLoader that reads from\n    // it's internal buffers.\n    if (contents != null) {\n      this._scannedDocumentPromises.delete(resolvedUrl);\n      this._scannedDocuments.delete(resolvedUrl);\n      this._parsedDocumentPromises.delete(resolvedUrl);\n      this._analyzedDocuments.delete(resolvedUrl);\n      this._analyzedDocumentPromises.delete(resolvedUrl);\n    }\n\n    const cachedResult = this._analyzedDocumentPromises.get(resolvedUrl);\n    if (cachedResult) {\n      return cachedResult;\n    }\n\n    const promise = (async() => {\n      // Make sure we wait and return a Promise before doing any work, so that\n      // the Promise is cached before anything else happens.\n      await Promise.resolve();\n      const doneTiming =\n          this._telemetryTracker.start('analyze: make document', url);\n      const scannedDocument = await this._scan(resolvedUrl, contents);\n      const document = this._makeDocument(scannedDocument);\n      doneTiming();\n      return document;\n    })();\n    this._analyzedDocumentPromises.set(resolvedUrl, promise);\n    return promise;\n  }\n\n  /**\n   * Constructs a new analyzed Document and adds it to the analyzed Document\n   * cache.\n   */\n  private _makeDocument(scannedDocument: ScannedDocument): Document {\n    const resolvedUrl = scannedDocument.url;\n\n    if (this._analyzedDocuments.has(resolvedUrl)) {\n      throw new Error(`Internal error: document ${resolvedUrl} already exists`);\n    }\n\n    const document = new Document(scannedDocument, this);\n    if (!this._analyzedDocumentPromises.has(resolvedUrl)) {\n      this._analyzedDocumentPromises.set(\n          resolvedUrl, Promise.resolve(document));\n    }\n    this._analyzedDocuments.set(resolvedUrl, document);\n    document.resolve();\n    return document;\n  }\n\n  /**\n   * Gets an analyzed Document from the document cache. This is only useful for\n   * Analyzer plugins. You almost certainly want to use `analyze()` instead.\n   *\n   * If a document has been analyzed, it returns the analyzed Document. If not\n   * the scanned document cache is used and a new analyzed Document is returned.\n   * If a file is in neither cache, it returns `undefined`.\n   */\n  _getDocument(url: string): Document|undefined {\n    const resolvedUrl = this._resolveUrl(url);\n    let document = this._analyzedDocuments.get(resolvedUrl);\n    if (document) {\n      return document;\n    }\n    const scannedDocument = this._scannedDocuments.get(resolvedUrl);\n    return scannedDocument && this._makeDocument(scannedDocument);\n  }\n\n  async getTelemetryMeasurements(): Promise<Measurement[]> {\n    return this._telemetryTracker.getMeasurements();\n  }\n\n  /**\n   * Clear all cached information from this analyzer instance.\n   *\n   * Note: if at all possible, instead tell the analyzer about the specific\n   * files that changed rather than clearing caches like this. Caching provides\n   * large performance gains.\n   */\n  clearCaches(): void {\n    this._scannedDocumentPromises.clear();\n    this._scannedDocuments.clear();\n    this._parsedDocumentPromises.clear();\n    this._analyzedDocuments.clear();\n    this._analyzedDocumentPromises.clear();\n  }\n\n  /**\n   * Scan a toplevel document given its url and optionally its contents.\n   */\n  private async _scan(resolvedUrl: string, contents?: string):\n      Promise<ScannedDocument> {\n    const cachedResult = this._scannedDocumentPromises.get(resolvedUrl);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    const promise = (async() => {\n      // Make sure we wait and return a Promise before doing any work, so that\n      // the Promise is cached before anything else happens.\n      await Promise.resolve();\n      const document = await this._parse(resolvedUrl, contents);\n      return this._scanDocument(document);\n    })();\n    this._scannedDocumentPromises.set(resolvedUrl, promise);\n    const scannedDocument = await promise;\n    await this._scanDependencies(scannedDocument);\n    return scannedDocument;\n  }\n\n  /**\n   * Parses and scans a document from source.\n   */\n  private async _scanInlineSource(\n      type: string, contents: string, url: string,\n      inlineInfo: InlineDocInfo<any>,\n      attachedComment?: string): Promise<ScannedDocument> {\n    const resolvedUrl = this._resolveUrl(url);\n    const parsedDoc =\n        this._parseContents(type, contents, resolvedUrl, inlineInfo);\n    const scannedDoc = await this._scanDocument(parsedDoc, attachedComment);\n    await this._scanDependencies(scannedDoc);\n    return scannedDoc;\n  }\n\n  /**\n   * Scans a ParsedDocument.\n   */\n  private async _scanDocument(\n      document: ParsedDocument<any, any>,\n      maybeAttachedComment?: string): Promise<ScannedDocument> {\n    const warnings: Warning[] = [];\n    const scannedFeatures = await this._getScannedFeatures(document);\n    // If there's an HTML comment that applies to this document then we assume\n    // that it applies to the first feature.\n    const firstScannedFeature = scannedFeatures[0];\n    if (firstScannedFeature && firstScannedFeature instanceof ScannedElement) {\n      firstScannedFeature.applyHtmlComment(maybeAttachedComment);\n    }\n\n    const scannedDocument =\n        new ScannedDocument(document, scannedFeatures, warnings);\n\n    if (!scannedDocument.isInline) {\n      this._scannedDocuments.set(scannedDocument.url, scannedDocument);\n    }\n    return scannedDocument;\n  }\n\n  /**\n   * Scan all the dependencies of the given scanned document.\n   *\n   * This must be called exactly once per scanned document, as we mutate\n   * the given scannedDocument by adding warnings.\n   */\n  private async _scanDependencies(scannedDocument: ScannedDocument):\n      Promise<void> {\n    const scannedDependencies: ScannedFeature[] =\n        scannedDocument.features.filter(\n            (e) => e instanceof ScannedInlineDocument ||\n                e instanceof ScannedImport);\n    const scannedSubDocuments =\n        scannedDependencies.map(async(scannedDependency) => {\n          if (scannedDependency instanceof ScannedInlineDocument) {\n            return this._scanInlineDocument(\n                scannedDependency,\n                scannedDocument.document,\n                scannedDocument.warnings);\n          } else if (scannedDependency instanceof ScannedImport) {\n            // TODO(garlicnation): Move this logic into model/document. During\n            // the recursive feature walk, features from lazy imports\n            // should be marked.\n            if (scannedDependency.type !== 'lazy-html-import') {\n              return this._scanImport(\n                  scannedDependency, scannedDocument.warnings);\n            }\n            return null;\n          } else {\n            throw new Error(`Unexpected dependency type: ${scannedDependency}`);\n          }\n        });\n    await Promise.all(scannedSubDocuments);\n  }\n\n  /**\n   * Scan an inline document found within a containing parsed doc.\n   */\n  private async _scanInlineDocument(\n      inlineDoc: ScannedInlineDocument,\n      containingDocument: ParsedDocument<any, any>,\n      warnings: Warning[]): Promise<ScannedDocument|null> {\n    const locationOffset: LocationOffset = {\n      line: inlineDoc.locationOffset.line,\n      col: inlineDoc.locationOffset.col,\n      filename: containingDocument.url\n    };\n    const inlineInfo = {locationOffset, astNode: inlineDoc.astNode};\n    try {\n      const scannedDocument = await this._scanInlineSource(\n          inlineDoc.type,\n          inlineDoc.contents,\n          containingDocument.url,\n          inlineInfo,\n          inlineDoc.attachedComment);\n      inlineDoc.scannedDocument = scannedDocument;\n      return scannedDocument;\n    } catch (err) {\n      if (err instanceof WarningCarryingException) {\n        warnings.push(err.warning);\n        return null;\n      }\n      throw err;\n    }\n  }\n\n  private async _scanImport(scannedImport: ScannedImport, warnings: Warning[]):\n      Promise<ScannedDocument|null> {\n    let scannedDocument: ScannedDocument;\n    try {\n      // HACK(rictic): this isn't quite right either, we need to get\n      //     the scanned dependency's url relative to the basedir don't\n      //     we?\n      scannedDocument = await this._scan(this._resolveUrl(scannedImport.url));\n    } catch (error) {\n      if (error instanceof NoKnownParserError) {\n        // We probably don't want to fail when importing something\n        // that we don't know about here.\n        return null;\n      }\n      error = error || '';\n      warnings.push({\n        code: 'could-not-load',\n        message: `Unable to load import: ${error.message || error}`,\n        sourceRange:\n            (scannedImport.urlSourceRange || scannedImport.sourceRange)!,\n        severity: Severity.ERROR\n      });\n      return null;\n    }\n    scannedImport.scannedDocument = scannedDocument;\n    return scannedDocument;\n  }\n\n  /**\n   * Loads the content at the provided resolved URL.\n   *\n   * Currently does no caching. If the provided contents are given then they\n   * are used instead of hitting the UrlLoader (e.g. when you have in-memory\n   * contents that should override disk).\n   */\n  async load(resolvedUrl: string, providedContents?: string) {\n    if (!this._loader.canLoad(resolvedUrl)) {\n      throw new Error(`Can't load URL: ${resolvedUrl}`);\n    }\n    return providedContents == null ? await this._loader.load(resolvedUrl) :\n                                      providedContents;\n  }\n\n  private async _parse(resolvedUrl: string, providedContents?: string):\n      Promise<ParsedDocument<any, any>> {\n    const cachedResult = this._parsedDocumentPromises.get(resolvedUrl);\n    if (cachedResult) {\n      return cachedResult;\n    }\n\n    // Use an immediately executed async function to create the final Promise\n    // synchronously so we can store it in this._documents before any other\n    // async operations to avoid any race conditions.\n    const promise = (async() => {\n      // Make sure we wait and return a Promise before doing any work, so that\n      // the Promise can be cached.\n      await Promise.resolve();\n\n      const content = await this.load(resolvedUrl, providedContents);\n      const extension = path.extname(resolvedUrl).substring(1);\n\n      const doneTiming = this._telemetryTracker.start('parse', 'resolvedUrl');\n      const parsedDoc = this._parseContents(extension, content, resolvedUrl);\n      doneTiming();\n      return parsedDoc;\n    })();\n    this._parsedDocumentPromises.set(resolvedUrl, promise);\n    return promise;\n  }\n\n  private _parseContents(\n      type: string, contents: string, url: string,\n      inlineInfo?: InlineDocInfo<any>): ParsedDocument<any, any> {\n    const parser = this._parsers.get(type);\n    if (parser == null) {\n      throw new NoKnownParserError(`No parser for for file type ${type}`);\n    }\n    try {\n      return parser.parse(contents, url, inlineInfo);\n    } catch (error) {\n      if (error instanceof WarningCarryingException) {\n        throw error;\n      }\n      throw new Error(`Error parsing ${url}:\\n ${error.stack}`);\n    }\n  }\n\n  private async _getScannedFeatures(document: ParsedDocument<any, any>):\n      Promise<ScannedFeature[]> {\n    const scanners = this._scanners.get(document.type);\n    if (scanners) {\n      return scan(document, scanners);\n    }\n    return [];\n  }\n\n  /**\n   * Resolves a URL with this Analyzer's `UrlResolver` if it has one, otherwise\n   * returns the given URL.\n   */\n  private _resolveUrl(url: string): string {\n    return this._resolver && this._resolver.canResolve(url) ?\n        this._resolver.resolve(url) :\n        url;\n  }\n}\n"]}