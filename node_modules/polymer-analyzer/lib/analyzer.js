/**
 * @license
 * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
/// <reference path="../custom_typings/main.d.ts" />
const path = require('path');
const css_parser_1 = require('./css/css-parser');
const html_element_reference_scanner_1 = require('./html/html-element-reference-scanner');
const html_import_scanner_1 = require('./html/html-import-scanner');
const html_parser_1 = require('./html/html-parser');
const html_script_scanner_1 = require('./html/html-script-scanner');
const html_style_scanner_1 = require('./html/html-style-scanner');
const javascript_parser_1 = require('./javascript/javascript-parser');
const json_parser_1 = require('./json/json-parser');
const model_1 = require('./model/model');
const telemetry_1 = require('./perf/telemetry');
const behavior_scanner_1 = require('./polymer/behavior-scanner');
const css_import_scanner_1 = require('./polymer/css-import-scanner');
const dom_module_scanner_1 = require('./polymer/dom-module-scanner');
const polymer_element_scanner_1 = require('./polymer/polymer-element-scanner');
const scan_1 = require('./scanning/scan');
const element_scanner_1 = require('./vanilla-custom-elements/element-scanner');
const warning_1 = require('./warning/warning');
class NoKnownParserError extends Error {
}
exports.NoKnownParserError = NoKnownParserError;
;
/**
 * A static analyzer for web projects.
 *
 * An Analyzer can load and parse documents of various types, and extract
 * arbitratrary information from the documents, and transitively load
 * dependencies. An Analyzer instance is configured with parsers, and scanners
 * which do the actual work of understanding different file types.
 */
class Analyzer {
    constructor(options) {
        this._parsers = new Map([
            ['html', new html_parser_1.HtmlParser()],
            ['js', new javascript_parser_1.JavaScriptParser({ sourceType: 'script' })],
            ['css', new css_parser_1.CssParser()],
            ['json', new json_parser_1.JsonParser()],
        ]);
        this._parsedDocumentPromises = new Map();
        this._scannedDocumentPromises = new Map();
        this._analyzedDocumentPromises = new Map();
        this._scannedDocuments = new Map();
        this._analyzedDocuments = new Map();
        this._telemetryTracker = new telemetry_1.TelemetryTracker();
        this._loader = options.urlLoader;
        this._resolver = options.urlResolver;
        this._parsers = options.parsers || this._parsers;
        this._lazyEdges = options.lazyEdges;
        this._scanners =
            options.scanners || Analyzer._getDefaultScanners(this._lazyEdges);
    }
    static _getDefaultScanners(lazyEdges) {
        return new Map([
            [
                'html',
                [
                    new html_import_scanner_1.HtmlImportScanner(lazyEdges),
                    new html_script_scanner_1.HtmlScriptScanner(),
                    new html_style_scanner_1.HtmlStyleScanner(),
                    new dom_module_scanner_1.DomModuleScanner(),
                    new css_import_scanner_1.CssImportScanner(),
                    new html_element_reference_scanner_1.HtmlCustomElementReferenceScanner()
                ]
            ],
            [
                'js',
                [
                    new polymer_element_scanner_1.PolymerElementScanner(),
                    new behavior_scanner_1.BehaviorScanner(),
                    new element_scanner_1.ElementScanner()
                ]
            ],
        ]);
    }
    /**
     * Loads, parses and analyzes the root document of a dependency graph and its
     * transitive dependencies.
     *
     * Note: The analyzer only supports analyzing a single root for now. This
     * is because each analyzed document in the dependency graph has a single
     * root. This mean that we can't properly analyze app-shell-style, lazy
     * loading apps.
     *
     * @param contents Optional contents of the file when it is known without
     * reading it from disk. Clears the caches so that the news contents is used
     * and reanalyzed. Useful for editors that want to re-analyze changed files.
     */
    analyze(url, contents) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolvedUrl = this._resolveUrl(url);
            // if we're given new contents, clear the cache
            // TODO(justinfagnani): It might be better to preserve a single code path
            // for loading file contents via UrlLoaders, and just offer a method to
            // re-analyze a particular file. Editors can use a UrlLoader that reads from
            // it's internal buffers.
            if (contents != null) {
                this._scannedDocumentPromises.delete(resolvedUrl);
                this._scannedDocuments.delete(resolvedUrl);
                this._parsedDocumentPromises.delete(resolvedUrl);
                this._analyzedDocuments.delete(resolvedUrl);
                this._analyzedDocumentPromises.delete(resolvedUrl);
            }
            const cachedResult = this._analyzedDocumentPromises.get(resolvedUrl);
            if (cachedResult) {
                return cachedResult;
            }
            const promise = (() => __awaiter(this, void 0, void 0, function* () {
                // Make sure we wait and return a Promise before doing any work, so that
                // the Promise is cached before anything else happens.
                yield Promise.resolve();
                const doneTiming = this._telemetryTracker.start('analyze: make document', url);
                const scannedDocument = yield this._scan(resolvedUrl, contents);
                const document = this._makeDocument(scannedDocument);
                doneTiming();
                return document;
            }))();
            this._analyzedDocumentPromises.set(resolvedUrl, promise);
            return promise;
        });
    }
    /**
     * Constructs a new analyzed Document and adds it to the analyzed Document
     * cache.
     */
    _makeDocument(scannedDocument) {
        const resolvedUrl = scannedDocument.url;
        if (this._analyzedDocuments.has(resolvedUrl)) {
            throw new Error(`Internal error: document ${resolvedUrl} already exists`);
        }
        const document = new model_1.Document(scannedDocument, this);
        if (!this._analyzedDocumentPromises.has(resolvedUrl)) {
            this._analyzedDocumentPromises.set(resolvedUrl, Promise.resolve(document));
        }
        this._analyzedDocuments.set(resolvedUrl, document);
        document.resolve();
        return document;
    }
    /**
     * Gets an analyzed Document from the document cache. This is only useful for
     * Analyzer plugins. You almost certainly want to use `analyze()` instead.
     *
     * If a document has been analyzed, it returns the analyzed Document. If not
     * the scanned document cache is used and a new analyzed Document is returned.
     * If a file is in neither cache, it returns `undefined`.
     */
    _getDocument(url) {
        const resolvedUrl = this._resolveUrl(url);
        let document = this._analyzedDocuments.get(resolvedUrl);
        if (document) {
            return document;
        }
        const scannedDocument = this._scannedDocuments.get(resolvedUrl);
        return scannedDocument && this._makeDocument(scannedDocument);
    }
    getTelemetryMeasurements() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._telemetryTracker.getMeasurements();
        });
    }
    /**
     * Clear all cached information from this analyzer instance.
     *
     * Note: if at all possible, instead tell the analyzer about the specific
     * files that changed rather than clearing caches like this. Caching provides
     * large performance gains.
     */
    clearCaches() {
        this._scannedDocumentPromises.clear();
        this._scannedDocuments.clear();
        this._parsedDocumentPromises.clear();
        this._analyzedDocuments.clear();
        this._analyzedDocumentPromises.clear();
    }
    /**
     * Scan a toplevel document given its url and optionally its contents.
     */
    _scan(resolvedUrl, contents) {
        return __awaiter(this, void 0, void 0, function* () {
            const cachedResult = this._scannedDocumentPromises.get(resolvedUrl);
            if (cachedResult) {
                return cachedResult;
            }
            const promise = (() => __awaiter(this, void 0, void 0, function* () {
                // Make sure we wait and return a Promise before doing any work, so that
                // the Promise is cached before anything else happens.
                yield Promise.resolve();
                const document = yield this._parse(resolvedUrl, contents);
                return this._scanDocument(document);
            }))();
            this._scannedDocumentPromises.set(resolvedUrl, promise);
            const scannedDocument = yield promise;
            yield this._scanDependencies(scannedDocument);
            return scannedDocument;
        });
    }
    /**
     * Parses and scans a document from source.
     */
    _scanInlineSource(type, contents, url, inlineInfo, attachedComment) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolvedUrl = this._resolveUrl(url);
            const parsedDoc = this._parseContents(type, contents, resolvedUrl, inlineInfo);
            const scannedDoc = yield this._scanDocument(parsedDoc, attachedComment);
            yield this._scanDependencies(scannedDoc);
            return scannedDoc;
        });
    }
    /**
     * Scans a ParsedDocument.
     */
    _scanDocument(document, maybeAttachedComment) {
        return __awaiter(this, void 0, void 0, function* () {
            const warnings = [];
            const scannedFeatures = yield this._getScannedFeatures(document);
            // If there's an HTML comment that applies to this document then we assume
            // that it applies to the first feature.
            const firstScannedFeature = scannedFeatures[0];
            if (firstScannedFeature && firstScannedFeature instanceof model_1.ScannedElement) {
                firstScannedFeature.applyHtmlComment(maybeAttachedComment);
            }
            const scannedDocument = new model_1.ScannedDocument(document, scannedFeatures, warnings);
            if (!scannedDocument.isInline) {
                this._scannedDocuments.set(scannedDocument.url, scannedDocument);
            }
            return scannedDocument;
        });
    }
    /**
     * Scan all the dependencies of the given scanned document.
     *
     * This must be called exactly once per scanned document, as we mutate
     * the given scannedDocument by adding warnings.
     */
    _scanDependencies(scannedDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            const scannedDependencies = scannedDocument.features.filter((e) => e instanceof model_1.ScannedInlineDocument ||
                e instanceof model_1.ScannedImport);
            const scannedSubDocuments = scannedDependencies.map((scannedDependency) => __awaiter(this, void 0, void 0, function* () {
                if (scannedDependency instanceof model_1.ScannedInlineDocument) {
                    return this._scanInlineDocument(scannedDependency, scannedDocument.document, scannedDocument.warnings);
                }
                else if (scannedDependency instanceof model_1.ScannedImport) {
                    // TODO(garlicnation): Move this logic into model/document. During
                    // the recursive feature walk, features from lazy imports
                    // should be marked.
                    if (scannedDependency.type !== 'lazy-html-import') {
                        return this._scanImport(scannedDependency, scannedDocument.warnings);
                    }
                    return null;
                }
                else {
                    throw new Error(`Unexpected dependency type: ${scannedDependency}`);
                }
            }));
            yield Promise.all(scannedSubDocuments);
        });
    }
    /**
     * Scan an inline document found within a containing parsed doc.
     */
    _scanInlineDocument(inlineDoc, containingDocument, warnings) {
        return __awaiter(this, void 0, void 0, function* () {
            const locationOffset = {
                line: inlineDoc.locationOffset.line,
                col: inlineDoc.locationOffset.col,
                filename: containingDocument.url
            };
            const inlineInfo = { locationOffset, astNode: inlineDoc.astNode };
            try {
                const scannedDocument = yield this._scanInlineSource(inlineDoc.type, inlineDoc.contents, containingDocument.url, inlineInfo, inlineDoc.attachedComment);
                inlineDoc.scannedDocument = scannedDocument;
                return scannedDocument;
            }
            catch (err) {
                if (err instanceof warning_1.WarningCarryingException) {
                    warnings.push(err.warning);
                    return null;
                }
                throw err;
            }
        });
    }
    _scanImport(scannedImport, warnings) {
        return __awaiter(this, void 0, void 0, function* () {
            let scannedDocument;
            try {
                // HACK(rictic): this isn't quite right either, we need to get
                //     the scanned dependency's url relative to the basedir don't
                //     we?
                scannedDocument = yield this._scan(this._resolveUrl(scannedImport.url));
            }
            catch (error) {
                if (error instanceof NoKnownParserError) {
                    // We probably don't want to fail when importing something
                    // that we don't know about here.
                    return null;
                }
                error = error || '';
                warnings.push({
                    code: 'could-not-load',
                    message: `Unable to load import: ${error.message || error}`,
                    sourceRange: (scannedImport.urlSourceRange || scannedImport.sourceRange),
                    severity: warning_1.Severity.ERROR
                });
                return null;
            }
            scannedImport.scannedDocument = scannedDocument;
            return scannedDocument;
        });
    }
    /**
     * Loads the content at the provided resolved URL.
     *
     * Currently does no caching. If the provided contents are given then they
     * are used instead of hitting the UrlLoader (e.g. when you have in-memory
     * contents that should override disk).
     */
    load(resolvedUrl, providedContents) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._loader.canLoad(resolvedUrl)) {
                throw new Error(`Can't load URL: ${resolvedUrl}`);
            }
            return providedContents == null ? yield this._loader.load(resolvedUrl) :
                providedContents;
        });
    }
    _parse(resolvedUrl, providedContents) {
        return __awaiter(this, void 0, void 0, function* () {
            const cachedResult = this._parsedDocumentPromises.get(resolvedUrl);
            if (cachedResult) {
                return cachedResult;
            }
            // Use an immediately executed async function to create the final Promise
            // synchronously so we can store it in this._documents before any other
            // async operations to avoid any race conditions.
            const promise = (() => __awaiter(this, void 0, void 0, function* () {
                // Make sure we wait and return a Promise before doing any work, so that
                // the Promise can be cached.
                yield Promise.resolve();
                const content = yield this.load(resolvedUrl, providedContents);
                const extension = path.extname(resolvedUrl).substring(1);
                const doneTiming = this._telemetryTracker.start('parse', 'resolvedUrl');
                const parsedDoc = this._parseContents(extension, content, resolvedUrl);
                doneTiming();
                return parsedDoc;
            }))();
            this._parsedDocumentPromises.set(resolvedUrl, promise);
            return promise;
        });
    }
    _parseContents(type, contents, url, inlineInfo) {
        const parser = this._parsers.get(type);
        if (parser == null) {
            throw new NoKnownParserError(`No parser for for file type ${type}`);
        }
        try {
            return parser.parse(contents, url, inlineInfo);
        }
        catch (error) {
            if (error instanceof warning_1.WarningCarryingException) {
                throw error;
            }
            throw new Error(`Error parsing ${url}:\n ${error.stack}`);
        }
    }
    _getScannedFeatures(document) {
        return __awaiter(this, void 0, void 0, function* () {
            const scanners = this._scanners.get(document.type);
            if (scanners) {
                return scan_1.scan(document, scanners);
            }
            return [];
        });
    }
    /**
     * Resolves a URL with this Analyzer's `UrlResolver` if it has one, otherwise
     * returns the given URL.
     */
    _resolveUrl(url) {
        return this._resolver && this._resolver.canResolve(url) ?
            this._resolver.resolve(url) :
            url;
    }
}
exports.Analyzer = Analyzer;

//# sourceMappingURL=analyzer.js.map
